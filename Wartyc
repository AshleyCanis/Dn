local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumpPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})




local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image





local Button = AimTab:CreateButton({
   Name = "Aimbot",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = true, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 5, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})


local Button = PlayerTab:CreateButton({
   Name = "Fly",
   Callback = function()
      loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\40\39\104\116\116\112\115\58\47\47\103\105\115\116\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\109\101\111\122\111\110\101\89\84\47\98\102\48\51\55\100\102\102\57\102\48\97\55\48\48\49\55\51\48\52\100\100\100\54\55\102\100\99\100\51\55\48\47\114\97\119\47\101\49\52\101\55\52\102\52\50\53\98\48\54\48\100\102\53\50\51\51\52\51\99\102\51\48\98\55\56\55\48\55\52\101\98\51\99\53\100\50\47\97\114\99\101\117\115\37\50\53\50\48\120\37\50\53\50\48\102\108\121\37\50\53\50\48\50\37\50\53\50\48\111\98\102\108\117\99\97\116\111\114\39\41\44\116\114\117\101\41\41\40\41\10\10")()
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image

local Button = AimTab:CreateButton({
   Name = "ESP",
   Callback = function()
      local Settings = {
         Box_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Thickness = 1,
         Box_Thickness = 1,
         Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
         Tracer_FollowMouse = false,
         Tracers = true
     }
     local Team_Check = {
         TeamCheck = false, -- if TeamColor is on this won't matter...
         Green = Color3.fromRGB(0, 255, 0),
         Red = Color3.fromRGB(255, 0, 0)
     }
     local TeamColor = true
     
     --// SEPARATION
     local player = game:GetService("Players").LocalPlayer
     local camera = game:GetService("Workspace").CurrentCamera
     local mouse = player:GetMouse()
     
     local function NewQuad(thickness, color)
         local quad = Drawing.new("Quad")
         quad.Visible = false
         quad.PointA = Vector2.new(0,0)
         quad.PointB = Vector2.new(0,0)
         quad.PointC = Vector2.new(0,0)
         quad.PointD = Vector2.new(0,0)
         quad.Color = color
         quad.Filled = false
         quad.Thickness = thickness
         quad.Transparency = 1
         return quad
     end
     
     local function NewLine(thickness, color)
         local line = Drawing.new("Line")
         line.Visible = false
         line.From = Vector2.new(0, 0)
         line.To = Vector2.new(0, 0)
         line.Color = color 
         line.Thickness = thickness
         line.Transparency = 1
         return line
     end
     
     local function Visibility(state, lib)
         for u, x in pairs(lib) do
             x.Visible = state
         end
     end
     
     local function ToColor3(col) --Function to convert, just cuz c;
         local r = col.r --Red value
         local g = col.g --Green value
         local b = col.b --Blue value
         return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
     end
     
     local black = Color3.fromRGB(0, 0 ,0)
     local function ESP(plr)
         local library = {
             --//Tracer and Black Tracer(black border)
             blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
             tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
             --//Box and Black Box(black border)
             black = NewQuad(Settings.Box_Thickness*2, black),
             box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
             --//Bar and Green Health Bar (part that moves up/down)
             healthbar = NewLine(3, black),
             greenhealth = NewLine(1.5, black)
         }
     
         local function Colorize(color)
             for u, x in pairs(library) do
                 if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                     x.Color = color
                 end
             end
         end
     
         local function Updater()
             local connection
             connection = game:GetService("RunService").RenderStepped:Connect(function()
                 if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                     local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                     if OnScreen then
                         local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                         local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                         
                         local function Size(item)
                             item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                             item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                             item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                             item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                         end
                         Size(library.box)
                         Size(library.black)
     
                         --//Tracer 
                         if Settings.Tracers then
                             if Settings.Tracer_Origin == "Middle" then
                                 library.tracer.From = camera.ViewportSize*0.5
                                 library.blacktracer.From = camera.ViewportSize*0.5
                             elseif Settings.Tracer_Origin == "Bottom" then
                                 library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                 library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                             end
                             if Settings.Tracer_FollowMouse then
                                 library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                 library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                             end
                             library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                             library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                         else 
                             library.tracer.From = Vector2.new(0, 0)
                             library.blacktracer.From = Vector2.new(0, 0)
                             library.tracer.To = Vector2.new(0, 0)
                             library.blacktracer.To = Vector2.new(0, 02)
                         end
     
                         --// Health Bar
                         local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                         local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
     
                         library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
     
                         library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
     
                         local green = Color3.fromRGB(0, 255, 0)
                         local red = Color3.fromRGB(255, 0, 0)
     
                         library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
     
                         if Team_Check.TeamCheck then
                             if plr.TeamColor == player.TeamColor then
                                 Colorize(Team_Check.Green)
                             else 
                                 Colorize(Team_Check.Red)
                             end
                         else 
                             library.tracer.Color = Settings.Tracer_Color
                             library.box.Color = Settings.Box_Color
                         end
                         if TeamColor == true then
                             Colorize(plr.TeamColor.Color)
                         end
                         Visibility(true, library)
                     else 
                         Visibility(false, library)
                     end
                 else 
                     Visibility(false, library)
                     if game.Players:FindFirstChild(plr.Name) == nil then
                         connection:Disconnect()
                     end
                 end
             end)
         end
         coroutine.wrap(Updater)()
     end
     
     for i, v in pairs(game:GetService("Players"):GetPlayers()) do
         if v.Name ~= player.Name then
             coroutine.wrap(ESP)(v)
         end
     end
     
     game.Players.PlayerAdded:Connect(function(newplr)
         if newplr.Name ~= player.Name then
             coroutine.wrap(ESP)(newplr)
         end
      end)
      
   end,
})

local Button = AimTab:CreateButton({
   Name = "AIMBOT",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local MTab = Window:CreateTab("Misc", 4483362458) -- Title, Image


local Button = MTab:CreateButton({
   Name = "Made by mrman37",
   Callback = function()

end,
})


local Button = MTab:CreateButton({
   Name = "Destroy UI",
   Callback = function()
Rayfield:Destroy()
end,
})

local Button = PlayerTab:CreateButton({
   Name = "Force Reset (Hit K)",
   Callback = function()
      local function forceResetAction()
         local player = game.Players.LocalPlayer
         if player.Character and player.Character:FindFirstChild("Humanoid") then
             player.Character.Humanoid.Health = 0
         end
     end
      
     -- Bind the function to a keyboard input (e.g., press 'K' to kill)
     game:GetService("UserInputService").InputBegan:Connect(function(input, isProcessed)
         if isProcessed then
             return
         end
      
         if input.KeyCode == Enum.KeyCode.K then
             forceResetAction()
         end
     end)
      
end,
})local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumpPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})




local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image





local Button = AimTab:CreateButton({
   Name = "Aimbot",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = true, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 5, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})


local Button = PlayerTab:CreateButton({
   Name = "Fly",
   Callback = function()
      loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\40\39\104\116\116\112\115\58\47\47\103\105\115\116\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\109\101\111\122\111\110\101\89\84\47\98\102\48\51\55\100\102\102\57\102\48\97\55\48\48\49\55\51\48\52\100\100\100\54\55\102\100\99\100\51\55\48\47\114\97\119\47\101\49\52\101\55\52\102\52\50\53\98\48\54\48\100\102\53\50\51\51\52\51\99\102\51\48\98\55\56\55\48\55\52\101\98\51\99\53\100\50\47\97\114\99\101\117\115\37\50\53\50\48\120\37\50\53\50\48\102\108\121\37\50\53\50\48\50\37\50\53\50\48\111\98\102\108\117\99\97\116\111\114\39\41\44\116\114\117\101\41\41\40\41\10\10")()
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image

local Button = AimTab:CreateButton({
   Name = "ESP",
   Callback = function()
      local Settings = {
         Box_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Thickness = 1,
         Box_Thickness = 1,
         Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
         Tracer_FollowMouse = false,
         Tracers = true
     }
     local Team_Check = {
         TeamCheck = false, -- if TeamColor is on this won't matter...
         Green = Color3.fromRGB(0, 255, 0),
         Red = Color3.fromRGB(255, 0, 0)
     }
     local TeamColor = true
     
     --// SEPARATION
     local player = game:GetService("Players").LocalPlayer
     local camera = game:GetService("Workspace").CurrentCamera
     local mouse = player:GetMouse()
     
     local function NewQuad(thickness, color)
         local quad = Drawing.new("Quad")
         quad.Visible = false
         quad.PointA = Vector2.new(0,0)
         quad.PointB = Vector2.new(0,0)
         quad.PointC = Vector2.new(0,0)
         quad.PointD = Vector2.new(0,0)
         quad.Color = color
         quad.Filled = false
         quad.Thickness = thickness
         quad.Transparency = 1
         return quad
     end
     
     local function NewLine(thickness, color)
         local line = Drawing.new("Line")
         line.Visible = false
         line.From = Vector2.new(0, 0)
         line.To = Vector2.new(0, 0)
         line.Color = color 
         line.Thickness = thickness
         line.Transparency = 1
         return line
     end
     
     local function Visibility(state, lib)
         for u, x in pairs(lib) do
             x.Visible = state
         end
     end
     
     local function ToColor3(col) --Function to convert, just cuz c;
         local r = col.r --Red value
         local g = col.g --Green value
         local b = col.b --Blue value
         return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
     end
     
     local black = Color3.fromRGB(0, 0 ,0)
     local function ESP(plr)
         local library = {
             --//Tracer and Black Tracer(black border)
             blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
             tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
             --//Box and Black Box(black border)
             black = NewQuad(Settings.Box_Thickness*2, black),
             box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
             --//Bar and Green Health Bar (part that moves up/down)
             healthbar = NewLine(3, black),
             greenhealth = NewLine(1.5, black)
         }
     
         local function Colorize(color)
             for u, x in pairs(library) do
                 if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                     x.Color = color
                 end
             end
         end
     
         local function Updater()
             local connection
             connection = game:GetService("RunService").RenderStepped:Connect(function()
                 if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                     local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                     if OnScreen then
                         local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                         local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                         
                         local function Size(item)
                             item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                             item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                             item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                             item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                         end
                         Size(library.box)
                         Size(library.black)
     
                         --//Tracer 
                         if Settings.Tracers then
                             if Settings.Tracer_Origin == "Middle" then
                                 library.tracer.From = camera.ViewportSize*0.5
                                 library.blacktracer.From = camera.ViewportSize*0.5
                             elseif Settings.Tracer_Origin == "Bottom" then
                                 library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                 library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                             end
                             if Settings.Tracer_FollowMouse then
                                 library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                 library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                             end
                             library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                             library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                         else 
                             library.tracer.From = Vector2.new(0, 0)
                             library.blacktracer.From = Vector2.new(0, 0)
                             library.tracer.To = Vector2.new(0, 0)
                             library.blacktracer.To = Vector2.new(0, 02)
                         end
     
                         --// Health Bar
                         local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                         local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
     
                         library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
     
                         library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
     
                         local green = Color3.fromRGB(0, 255, 0)
                         local red = Color3.fromRGB(255, 0, 0)
     
                         library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
     
                         if Team_Check.TeamCheck then
                             if plr.TeamColor == player.TeamColor then
                                 Colorize(Team_Check.Green)
                             else 
                                 Colorize(Team_Check.Red)
                             end
                         else 
                             library.tracer.Color = Settings.Tracer_Color
                             library.box.Color = Settings.Box_Color
                         end
                         if TeamColor == true then
                             Colorize(plr.TeamColor.Color)
                         end
                         Visibility(true, library)
                     else 
                         Visibility(false, library)
                     end
                 else 
                     Visibility(false, library)
                     if game.Players:FindFirstChild(plr.Name) == nil then
                         connection:Disconnect()
                     end
                 end
             end)
         end
         coroutine.wrap(Updater)()
     end
     
     for i, v in pairs(game:GetService("Players"):GetPlayers()) do
         if v.Name ~= player.Name then
             coroutine.wrap(ESP)(v)
         end
     end
     
     game.Players.PlayerAdded:Connect(function(newplr)
         if newplr.Name ~= player.Name then
             coroutine.wrap(ESP)(newplr)
         end
      end)
      
   end,
})

local Button = AimTab:CreateButton({
   Name = "AIMBOT",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local MTab = Window:CreateTab("Misc", 4483362458) -- Title, Image


local Button = MTab:CreateButton({
   Name = "Made by mrman37",
   Callback = function()

end,
})


local Button = MTab:CreateButton({
   Name = "Destroy UI",
   Callback = function()
Rayfield:Destroy()
end,
})

local Button = PlayerTab:CreateButton({
   Name = "Force Reset (Hit K)",
   Callback = function()
      local function forceResetAction()
         local player = game.Players.LocalPlayer
         if player.Character and player.Character:FindFirstChild("Humanoid") then
             player.Character.Humanoid.Health = 0
         end
     end
      
     -- Bind the function to a keyboard input (e.g., press 'K' to kill)
     game:GetService("UserInputService").InputBegan:Connect(function(input, isProcessed)
         if isProcessed then
             return
         end
      
         if input.KeyCode == Enum.KeyCode.K then
             forceResetAction()
         end
     end)
      
end,
})local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumpPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})




local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image





local Button = AimTab:CreateButton({
   Name = "Aimbot",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = true, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 5, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})


local Button = PlayerTab:CreateButton({
   Name = "Fly",
   Callback = function()
      loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\40\39\104\116\116\112\115\58\47\47\103\105\115\116\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\109\101\111\122\111\110\101\89\84\47\98\102\48\51\55\100\102\102\57\102\48\97\55\48\48\49\55\51\48\52\100\100\100\54\55\102\100\99\100\51\55\48\47\114\97\119\47\101\49\52\101\55\52\102\52\50\53\98\48\54\48\100\102\53\50\51\51\52\51\99\102\51\48\98\55\56\55\48\55\52\101\98\51\99\53\100\50\47\97\114\99\101\117\115\37\50\53\50\48\120\37\50\53\50\48\102\108\121\37\50\53\50\48\50\37\50\53\50\48\111\98\102\108\117\99\97\116\111\114\39\41\44\116\114\117\101\41\41\40\41\10\10")()
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image

local Button = AimTab:CreateButton({
   Name = "ESP",
   Callback = function()
      local Settings = {
         Box_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Thickness = 1,
         Box_Thickness = 1,
         Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
         Tracer_FollowMouse = false,
         Tracers = true
     }
     local Team_Check = {
         TeamCheck = false, -- if TeamColor is on this won't matter...
         Green = Color3.fromRGB(0, 255, 0),
         Red = Color3.fromRGB(255, 0, 0)
     }
     local TeamColor = true
     
     --// SEPARATION
     local player = game:GetService("Players").LocalPlayer
     local camera = game:GetService("Workspace").CurrentCamera
     local mouse = player:GetMouse()
     
     local function NewQuad(thickness, color)
         local quad = Drawing.new("Quad")
         quad.Visible = false
         quad.PointA = Vector2.new(0,0)
         quad.PointB = Vector2.new(0,0)
         quad.PointC = Vector2.new(0,0)
         quad.PointD = Vector2.new(0,0)
         quad.Color = color
         quad.Filled = false
         quad.Thickness = thickness
         quad.Transparency = 1
         return quad
     end
     
     local function NewLine(thickness, color)
         local line = Drawing.new("Line")
         line.Visible = false
         line.From = Vector2.new(0, 0)
         line.To = Vector2.new(0, 0)
         line.Color = color 
         line.Thickness = thickness
         line.Transparency = 1
         return line
     end
     
     local function Visibility(state, lib)
         for u, x in pairs(lib) do
             x.Visible = state
         end
     end
     
     local function ToColor3(col) --Function to convert, just cuz c;
         local r = col.r --Red value
         local g = col.g --Green value
         local b = col.b --Blue value
         return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
     end
     
     local black = Color3.fromRGB(0, 0 ,0)
     local function ESP(plr)
         local library = {
             --//Tracer and Black Tracer(black border)
             blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
             tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
             --//Box and Black Box(black border)
             black = NewQuad(Settings.Box_Thickness*2, black),
             box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
             --//Bar and Green Health Bar (part that moves up/down)
             healthbar = NewLine(3, black),
             greenhealth = NewLine(1.5, black)
         }
     
         local function Colorize(color)
             for u, x in pairs(library) do
                 if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                     x.Color = color
                 end
             end
         end
     
         local function Updater()
             local connection
             connection = game:GetService("RunService").RenderStepped:Connect(function()
                 if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                     local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                     if OnScreen then
                         local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                         local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                         
                         local function Size(item)
                             item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                             item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                             item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                             item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                         end
                         Size(library.box)
                         Size(library.black)
     
                         --//Tracer 
                         if Settings.Tracers then
                             if Settings.Tracer_Origin == "Middle" then
                                 library.tracer.From = camera.ViewportSize*0.5
                                 library.blacktracer.From = camera.ViewportSize*0.5
                             elseif Settings.Tracer_Origin == "Bottom" then
                                 library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                 library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                             end
                             if Settings.Tracer_FollowMouse then
                                 library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                 library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                             end
                             library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                             library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                         else 
                             library.tracer.From = Vector2.new(0, 0)
                             library.blacktracer.From = Vector2.new(0, 0)
                             library.tracer.To = Vector2.new(0, 0)
                             library.blacktracer.To = Vector2.new(0, 02)
                         end
     
                         --// Health Bar
                         local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                         local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
     
                         library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
     
                         library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
     
                         local green = Color3.fromRGB(0, 255, 0)
                         local red = Color3.fromRGB(255, 0, 0)
     
                         library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
     
                         if Team_Check.TeamCheck then
                             if plr.TeamColor == player.TeamColor then
                                 Colorize(Team_Check.Green)
                             else 
                                 Colorize(Team_Check.Red)
                             end
                         else 
                             library.tracer.Color = Settings.Tracer_Color
                             library.box.Color = Settings.Box_Color
                         end
                         if TeamColor == true then
                             Colorize(plr.TeamColor.Color)
                         end
                         Visibility(true, library)
                     else 
                         Visibility(false, library)
                     end
                 else 
                     Visibility(false, library)
                     if game.Players:FindFirstChild(plr.Name) == nil then
                         connection:Disconnect()
                     end
                 end
             end)
         end
         coroutine.wrap(Updater)()
     end
     
     for i, v in pairs(game:GetService("Players"):GetPlayers()) do
         if v.Name ~= player.Name then
             coroutine.wrap(ESP)(v)
         end
     end
     
     game.Players.PlayerAdded:Connect(function(newplr)
         if newplr.Name ~= player.Name then
             coroutine.wrap(ESP)(newplr)
         end
      end)
      
   end,
})

local Button = AimTab:CreateButton({
   Name = "AIMBOT",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local MTab = Window:CreateTab("Misc", 4483362458) -- Title, Image


local Button = MTab:CreateButton({
   Name = "Made by mrman37",
   Callback = function()

end,
})


local Button = MTab:CreateButton({
   Name = "Destroy UI",
   Callback = function()
Rayfield:Destroy()
end,
})

local Button = PlayerTab:CreateButton({
   Name = "Force Reset (Hit K)",
   Callback = function()
      local function forceResetAction()
         local player = game.Players.LocalPlayer
         if player.Character and player.Character:FindFirstChild("Humanoid") then
             player.Character.Humanoid.Health = 0
         end
     end
      
     -- Bind the function to a keyboard input (e.g., press 'K' to kill)
     game:GetService("UserInputService").InputBegan:Connect(function(input, isProcessed)
         if isProcessed then
             return
         end
      
         if input.KeyCode == Enum.KeyCode.K then
             forceResetAction()
         end
     end)
      
end,
})local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumpPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})




local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image





local Button = AimTab:CreateButton({
   Name = "Aimbot",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = true, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 5, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})


local Button = PlayerTab:CreateButton({
   Name = "Fly",
   Callback = function()
      loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\40\39\104\116\116\112\115\58\47\47\103\105\115\116\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\109\101\111\122\111\110\101\89\84\47\98\102\48\51\55\100\102\102\57\102\48\97\55\48\48\49\55\51\48\52\100\100\100\54\55\102\100\99\100\51\55\48\47\114\97\119\47\101\49\52\101\55\52\102\52\50\53\98\48\54\48\100\102\53\50\51\51\52\51\99\102\51\48\98\55\56\55\48\55\52\101\98\51\99\53\100\50\47\97\114\99\101\117\115\37\50\53\50\48\120\37\50\53\50\48\102\108\121\37\50\53\50\48\50\37\50\53\50\48\111\98\102\108\117\99\97\116\111\114\39\41\44\116\114\117\101\41\41\40\41\10\10")()
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image

local Button = AimTab:CreateButton({
   Name = "ESP",
   Callback = function()
      local Settings = {
         Box_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Thickness = 1,
         Box_Thickness = 1,
         Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
         Tracer_FollowMouse = false,
         Tracers = true
     }
     local Team_Check = {
         TeamCheck = false, -- if TeamColor is on this won't matter...
         Green = Color3.fromRGB(0, 255, 0),
         Red = Color3.fromRGB(255, 0, 0)
     }
     local TeamColor = true
     
     --// SEPARATION
     local player = game:GetService("Players").LocalPlayer
     local camera = game:GetService("Workspace").CurrentCamera
     local mouse = player:GetMouse()
     
     local function NewQuad(thickness, color)
         local quad = Drawing.new("Quad")
         quad.Visible = false
         quad.PointA = Vector2.new(0,0)
         quad.PointB = Vector2.new(0,0)
         quad.PointC = Vector2.new(0,0)
         quad.PointD = Vector2.new(0,0)
         quad.Color = color
         quad.Filled = false
         quad.Thickness = thickness
         quad.Transparency = 1
         return quad
     end
     
     local function NewLine(thickness, color)
         local line = Drawing.new("Line")
         line.Visible = false
         line.From = Vector2.new(0, 0)
         line.To = Vector2.new(0, 0)
         line.Color = color 
         line.Thickness = thickness
         line.Transparency = 1
         return line
     end
     
     local function Visibility(state, lib)
         for u, x in pairs(lib) do
             x.Visible = state
         end
     end
     
     local function ToColor3(col) --Function to convert, just cuz c;
         local r = col.r --Red value
         local g = col.g --Green value
         local b = col.b --Blue value
         return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
     end
     
     local black = Color3.fromRGB(0, 0 ,0)
     local function ESP(plr)
         local library = {
             --//Tracer and Black Tracer(black border)
             blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
             tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
             --//Box and Black Box(black border)
             black = NewQuad(Settings.Box_Thickness*2, black),
             box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
             --//Bar and Green Health Bar (part that moves up/down)
             healthbar = NewLine(3, black),
             greenhealth = NewLine(1.5, black)
         }
     
         local function Colorize(color)
             for u, x in pairs(library) do
                 if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                     x.Color = color
                 end
             end
         end
     
         local function Updater()
             local connection
             connection = game:GetService("RunService").RenderStepped:Connect(function()
                 if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                     local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                     if OnScreen then
                         local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                         local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                         
                         local function Size(item)
                             item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                             item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                             item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                             item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                         end
                         Size(library.box)
                         Size(library.black)
     
                         --//Tracer 
                         if Settings.Tracers then
                             if Settings.Tracer_Origin == "Middle" then
                                 library.tracer.From = camera.ViewportSize*0.5
                                 library.blacktracer.From = camera.ViewportSize*0.5
                             elseif Settings.Tracer_Origin == "Bottom" then
                                 library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                 library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                             end
                             if Settings.Tracer_FollowMouse then
                                 library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                 library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                             end
                             library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                             library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                         else 
                             library.tracer.From = Vector2.new(0, 0)
                             library.blacktracer.From = Vector2.new(0, 0)
                             library.tracer.To = Vector2.new(0, 0)
                             library.blacktracer.To = Vector2.new(0, 02)
                         end
     
                         --// Health Bar
                         local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                         local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
     
                         library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
     
                         library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
     
                         local green = Color3.fromRGB(0, 255, 0)
                         local red = Color3.fromRGB(255, 0, 0)
     
                         library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
     
                         if Team_Check.TeamCheck then
                             if plr.TeamColor == player.TeamColor then
                                 Colorize(Team_Check.Green)
                             else 
                                 Colorize(Team_Check.Red)
                             end
                         else 
                             library.tracer.Color = Settings.Tracer_Color
                             library.box.Color = Settings.Box_Color
                         end
                         if TeamColor == true then
                             Colorize(plr.TeamColor.Color)
                         end
                         Visibility(true, library)
                     else 
                         Visibility(false, library)
                     end
                 else 
                     Visibility(false, library)
                     if game.Players:FindFirstChild(plr.Name) == nil then
                         connection:Disconnect()
                     end
                 end
             end)
         end
         coroutine.wrap(Updater)()
     end
     
     for i, v in pairs(game:GetService("Players"):GetPlayers()) do
         if v.Name ~= player.Name then
             coroutine.wrap(ESP)(v)
         end
     end
     
     game.Players.PlayerAdded:Connect(function(newplr)
         if newplr.Name ~= player.Name then
             coroutine.wrap(ESP)(newplr)
         end
      end)
      
   end,
})

local Button = AimTab:CreateButton({
   Name = "AIMBOT",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local MTab = Window:CreateTab("Misc", 4483362458) -- Title, Image


local Button = MTab:CreateButton({
   Name = "Made by mrman37",
   Callback = function()

end,
})


local Button = MTab:CreateButton({
   Name = "Destroy UI",
   Callback = function()
Rayfield:Destroy()
end,
})

local Button = PlayerTab:CreateButton({
   Name = "Force Reset (Hit K)",
   Callback = function()
      local function forceResetAction()
         local player = game.Players.LocalPlayer
         if player.Character and player.Character:FindFirstChild("Humanoid") then
             player.Character.Humanoid.Health = 0
         end
     end
      
     -- Bind the function to a keyboard input (e.g., press 'K' to kill)
     game:GetService("UserInputService").InputBegan:Connect(function(input, isProcessed)
         if isProcessed then
             return
         end
      
         if input.KeyCode == Enum.KeyCode.K then
             forceResetAction()
         end
     end)
      
end,
})local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumpPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})




local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image





local Button = AimTab:CreateButton({
   Name = "Aimbot",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = true, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 5, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "REVWARE | WAR TYCOON ",
    LoadingTitle = "Loading",
    LoadingSubtitle = "Cheaters always cheat",
    ConfigurationSaving = {
       Enabled = false,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "SOT cheeto"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Put key Here",
       Subtitle = "Key System",
       Note = "Check the  buyer channel to see if i update key",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"MIL"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
   })

   local TPTab = Window:CreateTab("Teleports", 4483362458) -- Title, Image

   local Button = TPTab:CreateButton({
      Name = "Charlie",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2501, 48, -1297)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   local Button = TPTab:CreateButton({
      Name = "Echo",
      Callback = function()
         local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-846, 48, -2435)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
         
      end,
   })

   
      local Button = TPTab:CreateButton({
         Name = "BRAVO",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2708, 48, -639)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })
   
      local Button = TPTab:CreateButton({
         Name = "Delta",
         Callback = function()
            local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
   local location = CFrame.new(-2025, 47, -2018)
   local humanoid = game.Players.LocalPlayer.Character.Humanoid
   humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
   wait(0.1)
   pl.CFrame = location
            
         end,
      })

      local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

local Slider = PlayerTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 200},
   Increment = 10,
   Suffix = "Walkspeed",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
   end,
})

local Button = TPTab:CreateButton({
   Name = "FoxTrot",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1118, 48, -2110)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Golf",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(1987, 48, -1575)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Hotel",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2853, 48, -1276)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Kilo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(3054, 48, -352)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Romeo",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2269, 48, 2385)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Victor",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(2375, 48, 2495)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Zulu",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2379, 48, 1487)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Alpha",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(-2754, 48, 470)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Slider = PlayerTab:CreateSlider({
   Name = "Jump Power",
   Range = {0, 200},
   Increment = 10,
   Suffix = "JumPower",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
   end,
})


local Button = PlayerTab:CreateButton({
   Name = "Fly",
   Callback = function()
      loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\40\39\104\116\116\112\115\58\47\47\103\105\115\116\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\109\101\111\122\111\110\101\89\84\47\98\102\48\51\55\100\102\102\57\102\48\97\55\48\48\49\55\51\48\52\100\100\100\54\55\102\100\99\100\51\55\48\47\114\97\119\47\101\49\52\101\55\52\102\52\50\53\98\48\54\48\100\102\53\50\51\51\52\51\99\102\51\48\98\55\56\55\48\55\52\101\98\51\99\53\100\50\47\97\114\99\101\117\115\37\50\53\50\48\120\37\50\53\50\48\102\108\121\37\50\53\50\48\50\37\50\53\50\48\111\98\102\108\117\99\97\116\111\114\39\41\44\116\114\117\101\41\41\40\41\10\10")()
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 1",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(71, 104, -2062)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local Button = TPTab:CreateButton({
   Name = "Oil rig 2",
   Callback = function()
      local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
local location = CFrame.new(72, 104, 3433)
local humanoid = game.Players.LocalPlayer.Character.Humanoid
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
wait(0.1)
pl.CFrame = location
      
   end,
})

local AimTab = Window:CreateTab("Aim/ESP", 4483362458) -- Title, Image

local Button = AimTab:CreateButton({
   Name = "ESP",
   Callback = function()
      local Settings = {
         Box_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Color = Color3.fromRGB(255, 0, 0),
         Tracer_Thickness = 1,
         Box_Thickness = 1,
         Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
         Tracer_FollowMouse = false,
         Tracers = true
     }
     local Team_Check = {
         TeamCheck = false, -- if TeamColor is on this won't matter...
         Green = Color3.fromRGB(0, 255, 0),
         Red = Color3.fromRGB(255, 0, 0)
     }
     local TeamColor = true
     
     --// SEPARATION
     local player = game:GetService("Players").LocalPlayer
     local camera = game:GetService("Workspace").CurrentCamera
     local mouse = player:GetMouse()
     
     local function NewQuad(thickness, color)
         local quad = Drawing.new("Quad")
         quad.Visible = false
         quad.PointA = Vector2.new(0,0)
         quad.PointB = Vector2.new(0,0)
         quad.PointC = Vector2.new(0,0)
         quad.PointD = Vector2.new(0,0)
         quad.Color = color
         quad.Filled = false
         quad.Thickness = thickness
         quad.Transparency = 1
         return quad
     end
     
     local function NewLine(thickness, color)
         local line = Drawing.new("Line")
         line.Visible = false
         line.From = Vector2.new(0, 0)
         line.To = Vector2.new(0, 0)
         line.Color = color 
         line.Thickness = thickness
         line.Transparency = 1
         return line
     end
     
     local function Visibility(state, lib)
         for u, x in pairs(lib) do
             x.Visible = state
         end
     end
     
     local function ToColor3(col) --Function to convert, just cuz c;
         local r = col.r --Red value
         local g = col.g --Green value
         local b = col.b --Blue value
         return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
     end
     
     local black = Color3.fromRGB(0, 0 ,0)
     local function ESP(plr)
         local library = {
             --//Tracer and Black Tracer(black border)
             blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
             tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
             --//Box and Black Box(black border)
             black = NewQuad(Settings.Box_Thickness*2, black),
             box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
             --//Bar and Green Health Bar (part that moves up/down)
             healthbar = NewLine(3, black),
             greenhealth = NewLine(1.5, black)
         }
     
         local function Colorize(color)
             for u, x in pairs(library) do
                 if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                     x.Color = color
                 end
             end
         end
     
         local function Updater()
             local connection
             connection = game:GetService("RunService").RenderStepped:Connect(function()
                 if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                     local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                     if OnScreen then
                         local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                         local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                         
                         local function Size(item)
                             item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                             item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                             item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                             item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                         end
                         Size(library.box)
                         Size(library.black)
     
                         --//Tracer 
                         if Settings.Tracers then
                             if Settings.Tracer_Origin == "Middle" then
                                 library.tracer.From = camera.ViewportSize*0.5
                                 library.blacktracer.From = camera.ViewportSize*0.5
                             elseif Settings.Tracer_Origin == "Bottom" then
                                 library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                 library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                             end
                             if Settings.Tracer_FollowMouse then
                                 library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                 library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                             end
                             library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                             library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                         else 
                             library.tracer.From = Vector2.new(0, 0)
                             library.blacktracer.From = Vector2.new(0, 0)
                             library.tracer.To = Vector2.new(0, 0)
                             library.blacktracer.To = Vector2.new(0, 02)
                         end
     
                         --// Health Bar
                         local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                         local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
     
                         library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
     
                         library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                         library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
     
                         local green = Color3.fromRGB(0, 255, 0)
                         local red = Color3.fromRGB(255, 0, 0)
     
                         library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
     
                         if Team_Check.TeamCheck then
                             if plr.TeamColor == player.TeamColor then
                                 Colorize(Team_Check.Green)
                             else 
                                 Colorize(Team_Check.Red)
                             end
                         else 
                             library.tracer.Color = Settings.Tracer_Color
                             library.box.Color = Settings.Box_Color
                         end
                         if TeamColor == true then
                             Colorize(plr.TeamColor.Color)
                         end
                         Visibility(true, library)
                     else 
                         Visibility(false, library)
                     end
                 else 
                     Visibility(false, library)
                     if game.Players:FindFirstChild(plr.Name) == nil then
                         connection:Disconnect()
                     end
                 end
             end)
         end
         coroutine.wrap(Updater)()
     end
     
     for i, v in pairs(game:GetService("Players"):GetPlayers()) do
         if v.Name ~= player.Name then
             coroutine.wrap(ESP)(v)
         end
     end
     
     game.Players.PlayerAdded:Connect(function(newplr)
         if newplr.Name ~= player.Name then
             coroutine.wrap(ESP)(newplr)
         end
      end)
      
   end,
})

local Button = AimTab:CreateButton({
   Name = "AIMBOT",
   Callback = function()
--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(255, 255, 255),
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
   end,
})

local MTab = Window:CreateTab("Misc", 4483362458) -- Title, Image


local Button = MTab:CreateButton({
   Name = "Made by mrman37",
   Callback = function()

end,
})


local Button = MTab:CreateButton({
   Name = "Destroy UI",
   Callback = function()
Rayfield:Destroy()
end,
})

local Button = PlayerTab:CreateButton({
   Name = "Force Reset (Hit K)",
   Callback = function()
      local function forceResetAction()
         local player = game.Players.LocalPlayer
         if player.Character and player.Character:FindFirstChild("Humanoid") then
             player.Character.Humanoid.Health = 0
         end
     end
      
     -- Bind the function to a keyboard input (e.g., press 'K' to kill)
     game:GetService("UserInputService").InputBegan:Connect(function(input, isProcessed)
         if isProcessed then
             return
         end
      
         if input.KeyCode == Enum.KeyCode.K then
             forceResetAction()
         end
     end)
      
end,
})
